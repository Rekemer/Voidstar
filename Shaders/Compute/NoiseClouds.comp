#version 450

layout(set = 0, binding = 0) uniform UniformBufferObject {
    mat4 view;
    mat4 proj;
    vec4 playerPos;
    float time;
    
} ubo;
// 1 - static noise for terrain,
// 2 -  dynamic noise for water rendering
//layout(set = 1, binding = 0, rgba8) uniform writeonly image2D[2] storageImage;
layout(set=1,binding = 2) uniform NoiseData {

    float frequence ;
	float amplitude ;
	float octaves ;
	float multipler;
	float exponent ;
	float scale;

    float normalStrength ;
	float waterScale;
    
} noiseData;
//   worley noise for clouds
layout(set = 1, binding =3 , rgba8) uniform writeonly image3D worleyNoiseImage;
layout(set = 1, binding =4) buffer StorageBuffer {
    vec3 points[];
};

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;


vec3 random(vec3 st)
{
	float dotProduct1 = dot(st, vec3(127.1, 311.7, 23423.1));
    float dotProduct2 = dot(st, vec3(269.5, 183.3, 21.2));
    float dotProduct3 = dot(st, vec3(129.5, 383.3, 11.2));
    float dotProduct4 = dot(st, vec3(26.5, 83.3, 2.2));

    vec3 sinResult = sin(vec3(dotProduct1, dotProduct2,dotProduct3));
    vec3 multiplied = sinResult * 43758.5453;

    return fract(multiplied);
}
const ivec3 offsets[] =
{
    // centre
    ivec3(0,0,0),
    // front face
    ivec3(0,0,1),
    ivec3(-1,1,1),
    ivec3(-1,0,1),
    ivec3(-1,-1,1),
    ivec3(0,1,1),
    ivec3(0,-1,1),
    ivec3(1,1,1),
    ivec3(1,0,1),
    ivec3(1,-1,1),
    // back face
    ivec3(0,0,-1),
    ivec3(-1,1,-1),
    ivec3(-1,0,-1),
    ivec3(-1,-1,-1),
    ivec3(0,1,-1),
    ivec3(0,-1,-1),
    ivec3(1,1,-1),
    ivec3(1,0,-1),
    ivec3(1,-1,-1),
    // ring around centre
    ivec3(-1,1,0),
    ivec3(-1,0,0),
    ivec3(-1,-1,0),
    ivec3(0,1,0),
    ivec3(0,-1,0),
    ivec3(1,1,0),
    ivec3(1,0,0),
    ivec3(1,-1,0)
};

float maxComponent(vec3 vec) {
    return max(vec.x, max(vec.y, vec.z));
}

float minComponent(vec3 vec) {
    return min(vec.x, min(vec.y, vec.z));
}
vec2 random2( vec2 p ) {
    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);
}
void main() {
	float scale = 100.2f;
    vec3 gridPos = vec3(ivec3(gl_GlobalInvocationID));
	vec3 imageSize = vec3(64,64,64);
//	vec3 coords= gridPos%imageSize;
    int CoordsX = int(gl_GlobalInvocationID.x) % 12;
    int CoordsY =  int(gl_GlobalInvocationID.y) % 12;
    int CoordsZ =  int(gl_GlobalInvocationID.z) % 12;
    // Grid size and number of cell centers
    const int gridSize = 64;
    const int numCells = 4;

    // vec3 cellCenters[numCells];

    // // Generate cell centers
    // for (int i = 0; i < numCells; ++i) {
    //     cellCenters[i] = random(gridPos) + coords;
    // }

    // // Calculate distances to cell centers and find the two closest
    // float minDist = 1000.0;

    // for (int i = 0; i < numCells; ++i) {
    //     float dist = length(cellCenters[i] - vec3(coords));
    //      // Keep the closer distance
    //     minDist= min(minDist, dist);
    // }

    // Calculate Worley noise value
  //  float worleyNoise = minDist;
   vec3 pos = vec3(gl_GlobalInvocationID) / imageSize;
   ivec3 cellID = ivec3(floor(pos * float(numCells)));
   float minSqrDst = 1;
//   for (int cellOffsetIndex = 0; cellOffsetIndex < 27; cellOffsetIndex ++)
//   { 
//         if(offsets[cellOffsetIndex].z != 0.f) continue;
//        ivec3 adjID = cellID + offsets[cellOffsetIndex];
//       // Adjacent cell is outside map, so wrap around to other side to allow for seamless tiling
//     //   //if (minComponent(adjID) == -1 || maxComponent(adjID) == numCells) {
//     //     if(false)
//     //   {  ivec3 wrappedID = (adjID + numCells) % ivec3(numCells);
//     //       int adjCellIndex = wrappedID.x + numCells * (wrappedID.y + wrappedID.z * numCells);
//     //       vec3 wrappedPoint = points[adjCellIndex];
//     //       // Offset the wrappedPoint by all offsets to find which is closest to samplePos
//     //       for (int wrapOffsetIndex = 0; wrapOffsetIndex < 27; wrapOffsetIndex ++) {
//     //           vec3 sampleOffset = (pos - (wrappedPoint + offsets[wrapOffsetIndex]));
//     //           minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
//     //       }
//     //   }
//       //else
//       {
         
//           int index = adjID.x + numCells*(adjID.y +adjID.z * numCells );
//           vec3 sampleOffset = pos - points[index];
//           minSqrDst = min(minSqrDst, dot(sampleOffset, sampleOffset));
//       } 
 // }
  vec2 point[4];
    point[0] = vec2(0.83,0.75);
    point[1] = vec2(0.60,0.07);
    point[2] = vec2(0.28,0.64);
    point[3] =  vec2(0.31,0.26);
  vec2 i_st = vec2(cellID.xy);
  vec2 f_st = fract(pos.xy*numCells);
//  // Iterate through the points positions
//     for (int i = 0; i < 4; i++) {
//          vec2 point = random2(i_st);
//         //float dist = distance(f_st, point[i]);
//         float dist = distance(f_st,point);
//         // Keep the closer distance
//         minSqrDst = min(minSqrDst, dist);
//     }
   for (int y= -1; y <= 1; y++) 
    {
        for (int x= -1; x <= 1; x++)
        {
            vec2 neighbor = vec2(float(x),float(y));

            // Random position from current + neighbor place in the grid
            vec2 point = random2(i_st + neighbor);


			// Vector between the pixel and the point
            vec2 diff = neighbor + point - f_st;

            // Distance to the point
            float dist = length(diff);

            // Keep the closer distance
            minSqrDst = min(minSqrDst, dist);
        }
    }
   // vec3 pointPos = points[index];
    // Normalize the noise value to [0, 1]
  //  worleyNoise = clamp(worleyNoise, 0.0, 1.0);

    // Output the noise value to the texture
    int index = cellID.x + numCells*(cellID.y +cellID.z * numCells );
    vec4 noiseValue = vec4(points[index],1);
   // minSqrDst = sqrt(minSqrDst);
    //noiseValue = vec4(pos,1);
    noiseValue = vec4(minSqrDst,minSqrDst,minSqrDst,1);
   // noiseValue = vec4(f_st,0,1);
   //noiseValue = vec4(i_st,0,1);
    imageStore(worleyNoiseImage, ivec3(gl_GlobalInvocationID),noiseValue );
}





